/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AwsObservation struct {
}

type AwsParameters struct {

	// Access key identifier
	// +kubebuilder:validation:Required
	AccessKeyIDSecretRef v1.SecretKeySelector `json:"accessKeyIdSecretRef" tf:"-"`

	// Instance profile name
	// +kubebuilder:validation:Optional
	InstanceProfileName *string `json:"instanceProfileName,omitempty" tf:"instance_profile_name,omitempty"`

	// Openstack tenant/project name for the account
	// +kubebuilder:validation:Required
	OpenstackBillingTenant *string `json:"openstackBillingTenant" tf:"openstack_billing_tenant,omitempty"`

	// The IAM role the control plane will use over assume-role
	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// Route table identifier
	// +kubebuilder:validation:Optional
	RouteTableID *string `json:"routeTableId,omitempty" tf:"route_table_id,omitempty"`

	// Secret access key
	// +kubebuilder:validation:Required
	SecretAccessKeySecretRef v1.SecretKeySelector `json:"secretAccessKeySecretRef" tf:"-"`

	// Security group identifier
	// +kubebuilder:validation:Optional
	SecurityGroupID *string `json:"securityGroupId,omitempty" tf:"security_group_id,omitempty"`

	// Virtual private cloud identifier
	// +kubebuilder:validation:Required
	VpcID *string `json:"vpcId" tf:"vpc_id,omitempty"`
}

type AzureObservation struct {
}

type AzureParameters struct {

	// +kubebuilder:validation:Optional
	AvailabilitySet *string `json:"availabilitySet,omitempty" tf:"availability_set,omitempty"`

	// +kubebuilder:validation:Required
	ClientID *string `json:"clientId" tf:"client_id,omitempty"`

	// +kubebuilder:validation:Required
	ClientSecretSecretRef v1.SecretKeySelector `json:"clientSecretSecretRef" tf:"-"`

	// Openstack tenant/project name for the account
	// +kubebuilder:validation:Required
	OpenstackBillingTenant *string `json:"openstackBillingTenant" tf:"openstack_billing_tenant,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroup *string `json:"resourceGroup,omitempty" tf:"resource_group,omitempty"`

	// +kubebuilder:validation:Optional
	RouteTable *string `json:"routeTable,omitempty" tf:"route_table,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroup *string `json:"securityGroup,omitempty" tf:"security_group,omitempty"`

	// +kubebuilder:validation:Optional
	Subnet *string `json:"subnet,omitempty" tf:"subnet,omitempty"`

	// +kubebuilder:validation:Required
	SubscriptionID *string `json:"subscriptionId" tf:"subscription_id,omitempty"`

	// +kubebuilder:validation:Required
	TenantID *string `json:"tenantId" tf:"tenant_id,omitempty"`

	// +kubebuilder:validation:Optional
	Vnet *string `json:"vnet,omitempty" tf:"vnet,omitempty"`
}

type CloudObservation struct {
}

type CloudParameters struct {

	// AWS cluster specification
	// +kubebuilder:validation:Optional
	Aws []AwsParameters `json:"aws,omitempty" tf:"aws,omitempty"`

	// Azire cluster specification
	// +kubebuilder:validation:Optional
	Azure []AzureParameters `json:"azure,omitempty" tf:"azure,omitempty"`

	// OpenStack cluster specification
	// +kubebuilder:validation:Optional
	Openstack []OpenstackParameters `json:"openstack,omitempty" tf:"openstack,omitempty"`
}

type ClusterObservation struct {
	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp,omitempty"`

	DeletionTimestamp *string `json:"deletionTimestamp,omitempty" tf:"deletion_timestamp,omitempty"`

	KubeConfig *string `json:"kubeConfig,omitempty" tf:"kube_config,omitempty"`
}

type ClusterParameters struct {

	// Data center name
	// +kubebuilder:validation:Required
	DcName *string `json:"dcName" tf:"dc_name,omitempty"`

	// Labels added to cluster
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// Reference project identifier
	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// Cluster specification
	// +kubebuilder:validation:Required
	Spec []SpecParameters `json:"spec" tf:"spec,omitempty"`

	// SSH keys attached to nodes
	// +kubebuilder:validation:Optional
	Sshkeys []*string `json:"sshkeys,omitempty" tf:"sshkeys,omitempty"`
}

type MachineNetworksObservation struct {
}

type MachineNetworksParameters struct {

	// Network CIDR
	// +kubebuilder:validation:Optional
	Cidr *string `json:"cidr,omitempty" tf:"cidr,omitempty"`

	// DNS servers
	// +kubebuilder:validation:Optional
	DNSServers []string `json:"dnsServers,omitempty" tf:"dns_servers,omitempty"`

	// Network gateway
	// +kubebuilder:validation:Optional
	Gateway *string `json:"gateway,omitempty" tf:"gateway,omitempty"`
}

type OpenstackObservation struct {
}

type OpenstackParameters struct {

	// Openstack application credentials ID
	// +kubebuilder:validation:Optional
	ApplicationCredentialsID *string `json:"applicationCredentialsId,omitempty" tf:"application_credentials_id,omitempty"`

	// Openstack application credentials secret
	// +kubebuilder:validation:Optional
	ApplicationCredentialsSecretSecretRef *v1.SecretKeySelector `json:"applicationCredentialsSecretSecretRef,omitempty" tf:"-"`

	// The floating ip pool used by all worker nodes to receive a public ip
	// +kubebuilder:validation:Optional
	FloatingIPPool *string `json:"floatingIpPool,omitempty" tf:"floating_ip_pool,omitempty"`

	// When specified, all worker nodes will be attached to this network. If not specified, a network, subnet & router will be created.
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// The openstack account's password
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// When specified, all worker nodes will be attached to this security group. If not specified, a security group will be created
	// +kubebuilder:validation:Optional
	SecurityGroup *string `json:"securityGroup,omitempty" tf:"security_group,omitempty"`

	// Change this to configure a different internal IP range for Nodes. Default: 192.168.1.0/24
	// +kubebuilder:validation:Optional
	SubnetCidr *string `json:"subnetCidr,omitempty" tf:"subnet_cidr,omitempty"`

	// When specified, all worker nodes will be attached to this subnet of specified network. If not specified, a network, subnet & router will be created.
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// The opestack project to use for billing
	// +kubebuilder:validation:Optional
	Tenant *string `json:"tenant,omitempty" tf:"tenant,omitempty"`

	// The openstack account's username
	// +kubebuilder:validation:Optional
	UsernameSecretRef *v1.SecretKeySelector `json:"usernameSecretRef,omitempty" tf:"-"`
}

type SpecObservation struct {
}

type SpecParameters struct {

	// Whether to enable audit logging or not
	// +kubebuilder:validation:Optional
	AuditLogging *bool `json:"auditLogging,omitempty" tf:"audit_logging,omitempty"`

	// Cloud provider specification
	// +kubebuilder:validation:Required
	Cloud []CloudParameters `json:"cloud" tf:"cloud,omitempty"`

	// Internal IP range for ClusterIP Pods
	// +kubebuilder:validation:Optional
	DomainName *string `json:"domainName,omitempty" tf:"domain_name,omitempty"`

	// SSH Agent as a daemon running on each node that can manage ssh keys. Disable it if you want to manage keys manually
	// +kubebuilder:validation:Optional
	EnableSSHAgent *bool `json:"enableSshAgent,omitempty" tf:"enable_ssh_agent,omitempty"`

	// Machine networks optionally specifies the parameters for IPAM
	// +kubebuilder:validation:Optional
	MachineNetworks []MachineNetworksParameters `json:"machineNetworks,omitempty" tf:"machine_networks,omitempty"`

	// Configure PodNodeSelector admission plugin at the apiserver
	// +kubebuilder:validation:Optional
	PodNodeSelector *bool `json:"podNodeSelector,omitempty" tf:"pod_node_selector,omitempty"`

	// Pod security policies allow detailed authorization of pod creation and updates
	// +kubebuilder:validation:Optional
	PodSecurityPolicy *bool `json:"podSecurityPolicy,omitempty" tf:"pod_security_policy,omitempty"`

	// Internal IP range for Pods
	// +kubebuilder:validation:Optional
	PodsCidr *string `json:"podsCidr,omitempty" tf:"pods_cidr,omitempty"`

	// Internal IP range for ClusterIP Services
	// +kubebuilder:validation:Optional
	ServicesCidr *string `json:"servicesCidr,omitempty" tf:"services_cidr,omitempty"`

	// Flatcar nodes reboot window
	// +kubebuilder:validation:Optional
	UpdateWindow []UpdateWindowParameters `json:"updateWindow,omitempty" tf:"update_window,omitempty"`

	// Cloud orchestrator version, either Kubernetes or OpenShift
	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type UpdateWindowObservation struct {
}

type UpdateWindowParameters struct {

	// Node reboot window duration
	// +kubebuilder:validation:Required
	Length *string `json:"length" tf:"length,omitempty"`

	// Node reboot window start time
	// +kubebuilder:validation:Required
	Start *string `json:"start" tf:"start,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,metakubejet}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
